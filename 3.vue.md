###  vue相关

> vue为什么是异步渲染

- 因为如果不采用异步更新，那么每次更新数据组件都会重新渲染，所以vue为了性能，采用异步更新，本轮数据更新结束后采用异步渲染。
- 数据更改之后，会调用notify()方法，通知watcher进行更新，依次调用watcher的updata方法，但是方法不会立即执行，而会把这个方法放到queuewatch队列中，最后通过nexttick异步进行一起更新渲染。

> nextTick的实现原理

- nextTick方法主要使用的宏任务和微任务这两种异步方法，定义了一个异步方法，多次调用nextTick会将方法存入队列，通过这个异步方法清空当前队列，所以这个nextTick就是异步方法


> vue双向绑定的原理是什么
* vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过ES5提供的Object.defineProperty()方法来劫持(监视)各个属性的setter,getter，在数据变动的时发布消息给订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送发送给绑定的视图，而不是对所有的数据都执行一次检测。

 * 具体的步骤：
        1.需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上getter和setter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
        2.compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
        3.Watcher订阅者是Observer和compile之间通信桥梁，主要做的事情是：
       - 在自身实例化时往属性订阅器(dep)里面添加自己
       - 自身必须有一个update()的方法
       - 待属性变动dep.notice()通知的时候，能调用自身的update()方法，并触发compile中绑定的回调
       4.MVVM作为数据绑定的入口，整合observer、compile和watcher三者，通过observer来监听自己的model数据变化，通过compile来编译模板指令，最终利用watcher搭起的observer和compile之间的通信桥梁，达到数据变化---试图更新;视图交互变化(input)-->数据model变更的双向绑定效果
* 版本比较： vue是基于依赖收集的双向绑定； 3.0版本之前使用Object.definePropetry,3.0新版使用Proxy
    1.基于数据劫持/依赖收集 的双向绑定的优点
    不需要显示的调用，Vue利用数据劫持+发布订阅，可以直接通知变化并且驱动视图
    直接得到精确的变化数据，劫持了属性setter，当属性值改变，我们可以精确的获取变化的内容newValue，不需要额外的diff操作
    2.Object.defineProperty的缺点
    不能监听数组：因为数组没有getter和setter，因为数组长度不确定，如果太长性能负担太大
    只能监听属性，而不是整个对象，需要遍历循环属性
    只能监听属性变化，不能监听属性的删减
    3.proxy的好处
    可以监听数组
    监听整个对象不是属性
    13种来截方法，强大很多
    返回新对象而不是直接修改原对象，更符合immutable；
    4.proxy的缺点
    兼容性不好，而且无法用polyfill磨平；

> 什么是MVVM?
- `MVVM`是 `model` 、 `view` 、 `viewModel` 的缩写，也是就是把以前用的 `mvc` 中的c即 `Controller` ，使用vm即 `viewmodel` 来代替进行数据操作。  `viewmodel` 是 `model` 和 `view` 两者之间的桥梁。数据会绑定到 `viewmodel` 层自动将数据渲染到视图，视图变化时会通知 `viewmodel` 对数据进行更新。

> vue2.x中如何监测数组变化
- 使用了数据劫持的方式，对数组的方法进行了重写，vue将data中的数组进行了原型链的重写，指向了自己定义的数组原型的方法，当调用数组的api时，通知依赖更新。如果数组中存在着引用类型，会对数组引用类型再次进行递归遍历，实现了对数组的监测。