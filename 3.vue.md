### vue 相关

> vue 为什么是异步渲染

- 因为如果不采用异步更新，那么每次更新数据组件都会重新渲染，所以 vue 为了性能，采用异步更新，本轮数据更新结束后采用异步渲染。
- 数据更改之后，会调用 notify()方法，通知 watcher 进行更新，依次调用 watcher 的 updata 方法，但是方法不会立即执行，而会把这个方法放到 queuewatch 队列中，最后通过 nexttick 异步进行一起更新渲染。

> nextTick 的实现原理

- nextTick 方法主要使用的宏任务和微任务这两种异步方法，定义了一个异步方法，多次调用 nextTick 会将方法存入队列，通过这个异步方法清空当前队列，所以这个 nextTick 就是异步方法

> vue 双向绑定的原理是什么

- vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 ES5 提供的 Object.defineProperty()方法来劫持(监视)各个属性的 setter,getter，在数据变动的时发布消息给订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送发送给绑定的视图，而不是对所有的数据都执行一次检测。

- 具体的步骤： 1.需要 observer 的数据对象进行递归遍历，包括子属性对象的属性，都加上 getter 和 setter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化
  2.compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
  3.Watcher 订阅者是 Observer 和 compile 之间通信桥梁，主要做的事情是： - 在自身实例化时往属性订阅器(dep)里面添加自己 - 自身必须有一个 update()的方法 - 待属性变动 dep.notice()通知的时候，能调用自身的 update()方法，并触发 compile 中绑定的回调
  4.MVVM 作为数据绑定的入口，整合 observer、compile 和 watcher 三者，通过 observer 来监听自己的 model 数据变化，通过 compile 来编译模板指令，最终利用 watcher 搭起的 observer 和 compile 之间的通信桥梁，达到数据变化---试图更新;视图交互变化(input)-->数据 model 变更的双向绑定效果
- 版本比较： vue 是基于依赖收集的双向绑定； 3.0 版本之前使用 Object.definePropetry,3.0 新版使用 Proxy 1.基于数据劫持/依赖收集 的双向绑定的优点
  不需要显示的调用，Vue 利用数据劫持+发布订阅，可以直接通知变化并且驱动视图
  直接得到精确的变化数据，劫持了属性 setter，当属性值改变，我们可以精确的获取变化的内容 newValue，不需要额外的 diff 操作
  2.Object.defineProperty 的缺点
  不能监听数组：因为数组没有 getter 和 setter，因为数组长度不确定，如果太长性能负担太大
  只能监听属性，而不是整个对象，需要遍历循环属性
  只能监听属性变化，不能监听属性的删减
  3.proxy 的好处
  可以监听数组
  监听整个对象不是属性
  13 种来截方法，强大很多
  返回新对象而不是直接修改原对象，更符合 immutable；
  4.proxy 的缺点
  兼容性不好，而且无法用 polyfill 磨平；

> 什么是 MVVM?

- `MVVM`是 `model` 、 `view` 、 `viewModel` 的缩写，也是就是把以前用的 `mvc` 中的 c 即 `Controller` ，使用 vm 即 `viewmodel` 来代替进行数据操作。 `viewmodel` 是 `model` 和 `view` 两者之间的桥梁。数据会绑定到 `viewmodel` 层自动将数据渲染到视图，视图变化时会通知 `viewmodel` 对数据进行更新。

> vue2.x 中如何监测数组变化

- 使用了数据劫持的方式，对数组的方法进行了重写，vue 将 data 中的数组进行了原型链的重写，指向了自己定义的数组原型的方法，当调用数组的 api 时，通知依赖更新。如果数组中存在着引用类型，会对数组引用类型再次进行递归遍历，实现了对数组的监测。

> vue 是如何实现响应式数据的呢？

- vue2.0 使用 Object.defineProperty 对 data 中的属性进行了重新的定义， Object.defineProperty 对数据的 getter 和 setter 进行了拦截，进行依赖收集，拦截属性的更新操作，然后进行通知。首先 vue 会使用 initData 初始化用户传入的数据，然后使用 new Observer 对数据进行观测，如果数据是一个对象就会调用 this.walk(value)对对象进行处理，内部使用 defineReactive 循环对象属性进行响应式变化，核心就是 Object.definProperty 重新定义数据。
  -vue3 使用的是 proxy
