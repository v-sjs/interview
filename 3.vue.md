### vue 相关

> vue 为什么是异步渲染

- 因为如果不采用异步更新，那么每次更新数据组件都会重新渲染，所以 vue 为了性能，采用异步更新，本轮数据更新结束后采用异步渲染。
- 数据更改之后，会调用 notify()方法，通知 watcher 进行更新，依次调用 watcher 的 updata 方法，但是方法不会立即执行，而会把这个方法放到 queuewatch 队列中，最后通过 nexttick 异步进行一起更新渲染。

> nextTick 的实现原理

- nextTick 方法主要使用的宏任务和微任务这两种异步方法，定义了一个异步方法，多次调用 nextTick 会将方法存入队列，通过这个异步方法清空当前队列，所以这个 nextTick 就是异步方法

> vue 响应式数据的原理

- 核心是 object.defineProperty()
- vue 在通过 initData 初始化用户传入的数据，然后通过 observer 判断数据是否观测过，如果没观测过会通过 new Observer 对数据进行观测，然后调用 this.walk()重新定义对象的所有属性，通过 defineReactive 定义响应式，如果对象的值还是一个对象会进行递归观测。然后通过 defineProperty 对对象的 get 方法中的 dep.depend 进行依赖收集，然后通知 set 去更新数据如果值不一样通过 dep.notify 触发对应的依赖通知视图进行更新。

> vue 双向绑定的原理是什么

- vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 ES5 提供的 Object.defineProperty()方法来劫持(监视)各个属性的 setter,getter，在数据变动的时发布消息给订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送发送给绑定的视图，而不是对所有的数据都执行一次检测。

- 具体的步骤： 1.需要 observer 的数据对象进行递归遍历，包括子属性对象的属性，都加上 getter 和 setter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化
  2.compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
  3.Watcher 订阅者是 Observer 和 compile 之间通信桥梁，主要做的事情是： - 在自身实例化时往属性订阅器(dep)里面添加自己 - 自身必须有一个 update()的方法 - 待属性变动 dep.notice()通知的时候，能调用自身的 update()方法，并触发 compile 中绑定的回调
  4.MVVM 作为数据绑定的入口，整合 observer、compile 和 watcher 三者，通过 observer 来监听自己的 model 数据变化，通过 compile 来编译模板指令，最终利用 watcher 搭起的 observer 和 compile 之间的通信桥梁，达到数据变化---试图更新;视图交互变化(input)-->数据 model 变更的双向绑定效果
- 版本比较： vue 是基于依赖收集的双向绑定； 3.0 版本之前使用 Object.definePropetry,3.0 新版使用 Proxy 1.基于数据劫持/依赖收集 的双向绑定的优点
  不需要显示的调用，Vue 利用数据劫持+发布订阅，可以直接通知变化并且驱动视图
  直接得到精确的变化数据，劫持了属性 setter，当属性值改变，我们可以精确的获取变化的内容 newValue，不需要额外的 diff 操作
  2.Object.defineProperty 的缺点
  不能监听数组：因为数组没有 getter 和 setter，因为数组长度不确定，如果太长性能负担太大
  只能监听属性，而不是整个对象，需要遍历循环属性
  只能监听属性变化，不能监听属性的删减
  3.proxy 的好处
  可以监听数组
  监听整个对象不是属性
  13 种来截方法，强大很多
  返回新对象而不是直接修改原对象，更符合 immutable；
  4.proxy 的缺点
  兼容性不好，而且无法用 polyfill 磨平；

> 什么是 MVVM?

- `MVVM`是 `model` 、 `view` 、 `viewModel` 的缩写，也是就是把以前用的 `mvc` 中的 c 即 `Controller` ，使用 vm 即 `viewmodel` 来代替进行数据操作。 `viewmodel` 是 `model` 和 `view` 两者之间的桥梁。数据会绑定到 `viewmodel` 层自动将数据渲染到视图，视图变化时会通知 `viewmodel` 对数据进行更新。

> vue2.x 中如何监测数组变化

- 使用了数据劫持的方式，对数组的方法进行了重写，vue 将 data 中的数组进行了原型链的重写，指向了自己定义的数组原型的方法，当调用数组的 api 时，通知依赖更新。如果数组中存在着引用类型，会对数组引用类型再次进行递归遍历，实现了对数组的监测。

> vue 是如何实现响应式数据的呢？

- vue2.0 使用 Object.defineProperty 对 data 中的属性进行了重新的定义， Object.defineProperty 对数据的 getter 和 setter 进行了拦截，进行依赖收集，拦截属性的更新操作，然后进行通知。首先 vue 会使用 initData 初始化用户传入的数据，然后使用 new Observer 对数据进行观测，如果数据是一个对象就会调用 this.walk(value)对对象进行处理，内部使用 defineReactive 循环对象属性进行响应式变化，核心就是 Object.definProperty 重新定义数据。
  -vue3 使用的是 proxy

> VUE3 有那些性能提升

1. 编译阶段，vue2 对一些静态节点也会 diff 和遍历是不需要的，造成很大的性能浪费。vue3 的 diff 算法的优化提升是增加了静态标记，就是对会发生变化的地方添加一个 flag 标记，发生变化时直接找到该地方。vue3 的静态提升：对不参与更新的元素只会被创建一次，在渲染时直接复用，避免了重复创建节点，优化了运行内存。
2. 源码体积缩小。移除了一些不常用的 api，任何以一个函数，在打包时，只有用到才会打包，不用的都去掉了。
3. 响应式系统，vue2 使用的 object.defineProperty 来实现响应式的，而 vue3 使用的时 proxy 做的响应式。

> computed 和 watch 的区别

- computed 是具有缓存的计算属性，当数据变化时更新视图，适用于较消耗性能的计算场景，当表达式过于复杂时，放入模版难以维护，所以将较复杂的表达式放入计算属性
- watch 是没有缓存的，更多的是监听数据执行回调，需要深度的监听回调需要打开 deep：true，对对象的每一项进行监听。

> vue 的 mixin

- mixin 提供了一种灵活的方式来分发 vue 可复用功能。一个混入对象可以包含任意组件选项，当组件混入对象时，所有的混入对象的选项进入该组件自身的选项。
- 选项合并：
  当混入选项进入组件时，选项以恰当的方式进行合并，数据对象合并时会进行递归合并，发生冲突以组件数据优先。
  同名钩子函数合并为一个数组，混入对象的钩子在组件自身钩子之前调用。
  值为对象的属性，将会被合并为同一对象，两个对象冲突时，取组件自身的键值对。
- 全局混入：
  混入，也可以进行全局注册。需要小心使用，所有的实例都将受到影响包括第三方组件。
- 自定义选项合并：
  自定义选项默认使用自定义策略，即简单覆盖已有的值。如果想让自定义选项以自定义逻辑合并，可以向`vue.config.optionMergeStrategies`添加一个函数。
